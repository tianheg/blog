#+TITLE: How to Read the ECMAScript Specification
#+DATE: <2023-02-17 Fri 13:35>
#+TAGS[]: 技术 JavaScript

[[https://timothygu.me/es-howto/][How to Read the ECMAScript Specification]]

* 1. 前言

注意：在本文档中，将仅使用术语“ECMAScript”来指代规范本身，并在其他任何地方使用“JavaScript”。然而，这两个术语指的是同一件事。

** 为什么要阅读 ECMAScript 规范

ECMAScript 规范是 JavaScript 实现的权威资源，不论是在浏览器、通过 Node.js 的服务器、还是物联网终端。JavaScript 引擎的所有开发人员都依赖于规范来确保他们闪亮的新特性按照预期的方式工作，就像其他 JavaScript 引擎一样。

作者认为，了解 ECMAScript 规范不仅对 JavaScript 引擎开发者有帮助，对于仅使用 JavaScript 进行编码的人，了解 ECMAScript 规范也是非常有用的。

举例：

#+BEGIN_SRC js
> Array.prototype.push(42)
1
> Array.prototype
[ 42 ]
> Array.isArray(Array.prototype)
true
> Set.prototypeadd(42)
Uncaught TypeError: add method called on incompatible Set.prototype
> Set.prototype
Set {}
#+END_SRC

为什么 Array 的 push 方法可以作用到它的原型上，Set 的 add 方法就不行？Google 有时在你最需要的时候帮不了你，甚至是 Stack Overflow。

读规范可以帮你。

或者你想知道松散相等运算符的详细用法，MDN 帮不了你太多。

读规范可以帮你。

不推荐刚学习 JavaScript 的开发者读规范。

** 什么属于 ECMAScript 规范，什么不属于

|                                                                                                              | True/False |
|--------------------------------------------------------------------------------------------------------------+------------|
| Syntax of syntactic elements (i.e., what a valid =for= .. =in=  loop looks like)                             | T          |
| Semantics of syntactic elements (i.e., what =typeof null=, or ={ a: b }=  returns)                           | T          |
| =import a from 'a';=                                                                                         | F          |
| Object, Array, Function, Number, Math, RegExp, Proxy, Map, Promise, ArrayBuffer, Uint8Array, globalThis, ... | T          |
| console, setTimeout(), setInterval(), clearTimeout(), clearInterval()                                        | F          |
| Buffer, process, global*                                                                                     | F          |
| module, exports, require(), __dirname, __filename                                                            | F          |
| window, alert(), confirm(), the DOM (document, HTMLElement, addEventListener(), Worker, ...)                 | F          |


- =import a from 'a';= ECMAScript 规范指定了如此声明的语法，以及它们的意思，却没有指定模块是如何加载的。
- console, setTimeout(), setInterval(), clearTimeout(), clearInterval() 这些内容存在于浏览器和 Node.js 端，但不是规范中的。
- Buffer, process, global* 仅存在于 Node.js 中，在全局上下文起作用。与 =global= 不同， =globalThis= 是 ECMAScript 的一部分，在浏览器中也有实现。
- module, exports, require(), __dirname, __filename 仅存在于 Node.js 的全局上下文。
- window, alert(), confirm(), the DOM (document, HTMLElement, addEventListener(), Worker, ...) 仅存在于浏览器。

** ECMAScript 在哪里

最新更新：tc39.es/ecma262

** 导航规范

不要从头到尾读规范，这样做费时间低效率。要有针对性地阅读规范，比如，你今天对字符串感兴趣，就专门找字符串相关的章节阅读，这样一个主题一个主题地读，不至于半途而废。

* 2. 运行时语义（Runtime semantics）

语言和 API 的运行时语义是规范中最重要的部分，通常也是人们最关心的部分。

** 算法步骤

#+BEGIN_QUOTE
1. Let a be 1.
2. Let b be a+a.
3. If b is 2, then
   1. Hooray! Arithmetics isn’t broken.
4. Else
   1. Boo!
#+END_QUOTE

进一步阅读：[[https://tc39.es/ecma262/#sec-algorithm-conventions][5.2 Algorithm Conventions]]

** 抽象操作

有时会在规范中看到一些像函数的调用。Boolean() 函数的第一步是：

#+BEGIN_QUOTE
例子：

当 Boolean 带着参数值调用时，会采用以下步骤：

1. Let b ! ToBoolean(value).
2. ...
#+END_QUOTE

“ToBoolean”函数被称为抽象操作：说它抽象是因为，它并不是真的作为一个函数供 JavaScript 调用。这是一个标记，规范作者发明的避免重复写相同内容的方法。

** =[[This]]= 是什么

=[[Notation]]= 是一个标记，在不同语境下有不同的含义。以下是三个主要意义：

一、记录的字段

ECMAScript 规范使用 Record 指代键值图，具有固定键的集合——有点像 C 语言中的结构体。Record 中的每个键值对被叫做 field。因为 Records 只出现在规范中，实际 JavaScript 代码并不存在。那使用 =[[Notation]]= 指代 Record 的 fields 就说得通了。

#+BEGIN_QUOTE
例子：

很明显，属性描述符也由带有 fields =[[Value]]= , =[[Writable]]= , =[[Get]]= , =[[Set]]= , =[[Enumerable]]= , 和 =[[Configurable]]= 的 Records 建模。isDataDescriptor 抽象操作经常使用这种标记。

当属性描述符 Desc 调用抽象操作 isDataDescriptor 时，会进行以下步骤：

1. Desc undefiend，返回 false
2. =Desc.[[Value]]= 和 =Desc.[[Writable]]= 未设定，返回 false
3. 返回 true
#+END_QUOTE

进一步阅读：[[https://tc39.es/ecma262/#sec-list-and-record-specification-type][The List and Record Specification Types]]

二、JavaScript 对象的内部槽

#+BEGIN_QUOTE
例子：

大多数 JavaScript 对象有内部槽 =[[Prototype]]= 用来指代它们继承的对象，内部槽的值通常是 =Object.getPrototypeOf()= 返回值。在 OrdinaryGetPrototypeOf 抽象操作中，内部槽的值可以这样得到：

对象 O 调用抽象操作 OrdinaryGetPrototypeOf，进行以下步骤：

1. 返回 =O.[[Prototype]]= .
#+END_QUOTE

注意: Object 和 Record 字段的内部槽在外观上是相同的，但是可以通过查看这种表示法的前例（点之前的部分）来消除它们的歧义，无论它是 Object 还是 Record。从上下语境来看，这一点通常相当明显。

三、JavaScript 对象的内部方法

这些内部方法无法在 JavaScript 中直接访问到。

#+BEGIN_QUOTE
例子：

所有 JavaScript 函数都有内部方法 =[[Call]]= ，用来执行该函数。Call 抽象操作的执行步骤：

1. 返回 ? =F.[[Call]](V, argumentsList)=
#+END_QUOTE

** 完成记录； =?= 和 =!=

ECMAScript 规范中的每个运行时语义都显式或隐式地返回一个报告其结果的完成记录。这个完成记录是一个包含三个可能字段的记录：

- a =[[Type]]= ( =normal= , =return= , =throw= , =break= 或 =continue= )
- 如果 =[[Type]]= 是 nomral, return, throw，还会有 =[[Value]]= （看看返回或者抛出什么）
- 如果 =[[Type]]= 是 break, continue，那么它可以有选择地携带一个 =[[Target]]= 标签，脚本执行从这里开始

=[[Type]]= 是 normal 的完成记录是 normal completion，其他的情况称为 abrupt completion。

很多时候，只需要处理 =[[Type]]= 为 throw 的 abrupt completion。其他三种 abrupt completion 类型只有在查看如何计算特定语法元素时才有用。实际上，在内置函数的定义中，你永远不会看到任何其他类型，因为 =break= , =continue= , =return= 不能跨函数边界工作。

进一步阅读：[[https://tc39.es/ecma262/#sec-completion-record-specification-type][The Completion Record Specification Type]]



** JavaScript 对象

** 例子： =String.prototype.substring()=

** 例子： =Boolean()= 和 =String()= 可以抛出例外吗

** 例子： =typeof= 操作符

参考资料

- [[https://github.com/Pines-Cheng/blog/issues/63][怎样阅读 ECMAScript 规范？]]
