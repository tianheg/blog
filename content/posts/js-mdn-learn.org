#+TITLE: JS MDN Learn
#+DATE: <2022-10-25 Tue 21:59>
#+TAGS[]: 技术 JavaScript
#+TOC: true

系统学习 JavaScript 第一步——MDN 的 [[https://developer.mozilla.org/en-US/docs/Learn/JavaScript][Learn]] 部分，相当于基础入门。

{{< tasklist >}}
是否完成: No

## first steps

- [x]  [What is JavaScript?](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript)
- [x]  [A first splash into JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/A_first_splash)
- [x]  [What went wrong? Troubleshooting JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_went_wrong)
- [x]  [Storing the information you need — Variables](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Variables)
- [x]  [Basic math in JavaScript — numbers and operators](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Math)
- [x]  [Handling text — strings in JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Strings)
- [x]  [Useful string methods](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Useful_string_methods)
- [x]  [Arrays](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Arrays)
- [x]  **Assessments** [Silly story generator](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Silly_story_generator)

## building blocks

- [x]  [Making decisions in your code — conditionals](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/conditionals)
- [x]  [Looping code](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Looping_code)
- [x]  [Functions — reusable blocks of code](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Functions)
- [x]  [Build your own function](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Build_your_own_function)
- [x]  [Function return values](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Return_values)
- [x]  [Introduction to events](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events)
- [x]  **Assessments** [Image gallery](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Image_gallery)

## objects

- [ ]  [Object basics](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics)
- [ ]  [Object prototypes](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes)
- [ ]  [Object-oriented programming](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming)
- [ ]  [Classes in JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Classes_in_JavaScript)
- [ ]  [Working with JSON data](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON)
- [ ]  [Object building practice](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_building_practice)
- [ ]  **Assessments** [Adding features to our bouncing balls demo](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Adding_bouncing_balls_features)

## asynchronous JS

- [ ]  [Introducing asynchronous JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing)
- [ ]  [How to use promises](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises)
- [ ]  [Implementing a promise-based API](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API)
- [ ]  [Introducing workers](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing_workers)
- [ ]  **Assessments** [Sequencing animations](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Sequencing_animations)

## Client-side web APIs

- [ ]  [Introduction to web APIs](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Introduction)
- [ ]  [Manipulating documents](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents)
- [ ]  [Fetching data from the server](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data)
- [ ]  [Third party APIs](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Third_party_APIs)
- [ ]  [Drawing graphics](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Drawing_graphics)
- [ ]  [Video and audio APIs](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Video_and_audio_APIs)
- [ ]  [Client-side storage](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage)

## **Solving common JavaScript problems**

{{< /tasklist >}}

-----

* 第一步

** 什么是 JavaScript？

从全局来看 JS，讨论 JS 是什么、你能用它做什么等问题，明确使用 JS 的目的。

抽象定义：JS 是一种编程语言，允许你在网页中实现复杂功能。

还有，如果可以通过 CSS 对文本进行改变就不应该通过 JS 实现。

一段更新文本的 JS 代码：

#+BEGIN_SRC js
const para = document.querySelector('p');

para.addEventListener('click', updateName);

function updateName() {
  const name = prompt('Enter a new name');
  para.textContent = `Player 1: ${name}`;
}
#+END_SRC

有一些被称为 APIs（Application Programming Interfaces，应用编程接口）功能，大致分为两类——[[https://developer.mozilla.org/en-US/docs/Web/API][浏览器 APIs]] 和第三方 APIs。

JS 能在页面加载完毕后动态修改页面内容。每个浏览器标签都处在独立的执行环境互不干涉。JS 代码从上到下依次执行。

解释（interpreted）型代码与编译（compiled）型代码：对于解释型编程语言，代码从上到下依次执行，代码的执行结果是即刻返回的；对于编译型编程语言，在由电脑运行以前先被转换为另一种形式，例如 C 语言会被编译成机器码再被电脑执行。JS 是轻量级的解释型编程语言。现代 JS 解释器使用了一种名为即时编译（just-in-time compiling）的技术来改善性能，在实际运行 JS 代码时，代码会被转换为一种二进制格式，执行速度更快。虽然应用了该种技术，但 JS 仍被视为解释型编程语言，因为这里的编译过程是在运行时进行的而不是提前完成。

服务端（Server-side）代码与客户端（Client-side）代码：在本次 JS Learn 部分，讲述的全部是客户端 JS——运行在用户主机上的 JS 代码。服务端代码运行在服务器上，服务端编程语言有 PHP、Python。

动态代码与静态代码：动态包括客户端 JS 和服务端语言，它们能够在不同情况下更新网页显示不同内容，按需生成新内容。服务端代码在服务器生成新内容，而客户端 JS 在客户端的浏览器内生成。不会动态更新内容的网页被称为动态网页，我的博客就是这样的静态网页组成的，进而可称为静态博客。

** 第一次尝试 JavaScript

像程序员一样思考，通过程序解决现实生活中的问题。如何像程序员一样思考？

- 知道程序的功能
- 知道具备这些功能需要哪些代码层面的东西
- 如何将代码组合在一起工作

这需要各种努力：熟悉编程语言语法、持续练习以及一点创造力。

这一节给一个“猜数字”的例子，输入1-100的任意数字，程序根据是否与给定数字相等，并返回相应结果。

** 出了什么问题？JavaScript 故障排除

错误种类：语法错误和逻辑错误。

** 存储你需要的信息——变量

变量是值的容器，值可能是数字、字符串、布尔值、数组、对象、等等。可通过 const、let、var 声明变量。变量的初始化，const 必须初始化。变量[[https://developer.mozilla.org/en-US/docs/Glossary/Hoisting][提升]]。

** JavaScript 中的基本数学——数字和操作符

十进制数的不同类型：整数、浮点数、双精度浮点数。不同的数字系统：二进制、八进制、十六进制。JavaScript 对应的数据类型——[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number][Number]]。

一些 Number 方法：

- toFixed() 保留几位小数
- Number(string) 将字符串转化为数字

算术操作符：+、-、*、/、%、**（指数）。它们存在优先级，和数学中的一样，“先算乘除、后算加减”。自操作符： ~--~ 、++。赋值操作符：=、 ~+=~ 、 ~-=~ 、 ~*=~ 、 ~/=~ 。比较操作符： ~===~ 、 ~!==~ 、<、>、<=、>=。

** 在 JavaScript 中处理文本——字符串

JS 中的字符串——由单双引号围起的字符。用反斜杠转义引号。字符串拼接用 =``= 或 =+= 。用 =``= 或 =\n= 能输出多行字符串。

通过 =Number()= 可以把字符串转换成数字；而相应的，通过 =toString()= 可以把数字转换成字符串。

可以在字符串中插入运算符。

** 有用的字符串方法

- String length
- String[0]
- String.prototype.includes()
- String.prototype.startsWith()
- String.prototype.endsWith()
- String.prototype.indexOf()
- String.prototype.slice()
- String.prototype.toLowerCase()
- String.prototype.toUpperCase()
- String.prototype.replace()
- String.prototype.replaceAll()

** 数组

数组是一串字符串组成的一个分组。数组例子： ~['abc', 'def', '123', '456']~ ， ~['abc', 'def', [ '123', '456' ]]~ 。第二个是一个多维数组。

- Array.prototype.length
- Array[0]
- Array.prototype.indexOf()
- Array.prototype.push()
- Array.prototype.unshift()
- Array.prototype.pop()
- Array.prototype.shift()
- Array.prototype.splice()
- Array.prototype.map()
- Array.prototype.filter()
- String.prototype.split() 字符串转换成数组
- Array.prototype.join() 数组转换成字符串
- Array.prototype.toString() 数组转换成字符串

** 任务：蠢故事生成器

#+BEGIN_EXPORT html
<p class="codepen" data-height="334" data-default-tab="html,result" data-slug-hash="VwdvwNX" data-user="tianheg" style="height: 334px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/tianheg/pen/VwdvwNX">
  Silly story generator</a> by tianheg (<a href="https://codepen.io/tianheg">@tianheg</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
#+END_EXPORT

* 构建块

** 在代码中做决定——条件句

- if...else
- if...
- if...else if...else

使用逻辑操作符： ~&&~ , ~||~ , ~!~ 。

使用 switch 语句时，default 不是必须要加上去的。case 后只能跟一个值，可见以下对比：

#+BEGIN_SRC js
switch (expression) {
  case value1 || value2:
    ...
}

switch (expression) {
  case value1:
  case value2:
    ...
}
#+END_SRC

第一个 switch 用法错误（如果是表达式就可以用逻辑操作符连接，如下所示），第二个是正确的。

#+BEGIN_SRC js
switch (true) {
  case score >= 0 && score < 20:
    response = "";
    break;
  case score >= 20 && score < 40:
    response = "";
    break;
  case score >= 40 && score < 60:
    response = "";
    break;
  case score >= 60 && score < 80:
    response = "";
    break;
  case score >= 80 && score < 100:
    response = "";
    break;
}
#+END_SRC

三元操作符。

在进行条件判断时，false, undefined, null, 0, NaN, 空字符串 会返回 =false= ，其他情况均返回真。

** 循环

在一个元素集合中循环迭代，这些元素集合有几类——Array、Set、Map。

循环句式：

- for...of

更特殊的循环方法：map(), filter()。

标准 for 循环：

#+BEGIN_SRC js
for (initializer; condition; final-expression) {
  // code to run
}
#+END_SRC

注意，与 for...of 的区别。

break、continue

while:

#+BEGIN_SRC js
initializer
while (condition) {
  // code to run

  final-expression
}
#+END_SRC

如何选择循环句式：

1. 迭代数组时，不需要特别指定次序，使用 for...of 最佳
2. 其他情况，用 for while do...while 彼此大概率可互换

~person === "Phil" || person === "Lola"~ 和 ~person === ("Phil" || "Lola")~ 在 if 句式中并不相同，为何？

~phonebook[i].name.toLowerCase()~ 可以， ~phonebook[i][name].toLowerCase()~ 报错，为何？

#+BEGIN_SRC js
while (i > 1) {
  if (isPrime(i) === true) {
    para.textContent += `${i} `
  } else {
    i--
    continue
  }

  i--
}

// Refer:
// https://discourse.mozilla.org/t/assessment-request-for-loops-3-skill-test-confused-on-using-continue-statement-with-loops/67100
#+END_SRC

上面代码，如果没有第一个 ~i--~ 就会陷入无限循环。

** 函数——可复用的代码块

JS 有很多内建函数，比如 string.replace(), array.join(), Math.random() 等等。

如果函数是属于对象的就被称为方法。函数表达式、函数参数、指定默认函数参数、匿名函数与箭头函数、函数作用域。

可为函数指定默认参数。

#+BEGIN_SRC js
function hello(name = "Jim") {
  console.log(`Hello ${name}!`);
}

hello();
hello("tianheg");
#+END_SRC

匿名函数，函数表达式：

#+BEGIN_SRC js
(function () {
 alert('hello');
})

const helloAlert = function () {
  alert('hello');
}
#+END_SRC

与函数声明不同，函数表达式不提升。

函数作用域：

全局作用域


Test your skills: Functions 3 的解决办法：

#+BEGIN_SRC js
const names = [
  "Chris",
  "Li Kang",
  "Anne",
  "Francesca",
  "Mustafa",
  "Tina",
  "Bert",
  "Jada"
];
const para = document.createElement("p");
const section = document.querySelector("section");

// Add your code here
// Refer https://codepen.io/MacNulty/project/editor/XxYjLw
function random(lowerBound, upperBound) {
  return Math.floor(Math.random() * (upperBound - lowerBound)) + lowerBound;
}

function chooseName() {
  return names[random(0, 7)];
}
para.textContent = chooseName();

// Don't edit the code below here!

section.appendChild(para);
#+END_SRC
** 构建自己的函数

~btn.addEventListener("click", funcName)~ 与 ~btn.addEventListener("click", funcName())~ 有区别，前者只有 click 事件发生时才执行，后者只要页面 reload 就立即执行不等待 click 事件发生，在此种上下文中 ~funcName()~ 中的括号还被称为“函数调用运算符（function invocation operator）”。 ~btn.addEventListener("click", () => funcName("sth"))~ 此种匿名函数形式，则不会如上述第二种立即执行，该种不在立即执行的作用域中。

** 函数返回值

有些函数无返回值。通过函数返回计算值。使用 return 返回值。

** 介绍事件

#+BEGIN_SRC js
btn.addEventListener("click", () => {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
});
#+END_SRC

在 JS 中，面向网页的事件模型与用于其他环境的事件模型并不相同。

addEventListener(), removeEventListener() 第二个不明白如何使用，我以为添加一个事件，再通过第二个移除后，添加的事件会失效，但实际并非如此。使用 AbortController() 就可以：

#+BEGIN_SRC js
const clickTarget = document.querySelector("button");

const controller = new AbortController();

clickTarget.addEventListener("click", changeBackground, {
  signal: controller.signal
});

controller.abort();

function changeBackground() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}

function random(num) {
  return Math.floor(Math.random() * (num + 1));
}
#+END_SRC

#+BEGIN_SRC html
<button>Change color</button>
#+END_SRC

为单独事件添加多个监听器：

#+BEGIN_SRC js
myElement.addEventListener('click', functionA);
myElement.addEventListener('click', functionB);
#+END_SRC

当事件发生，两个函数都会执行。

其他注册事件处理程序的方式：

1, event handler properties

#+BEGIN_SRC js
btn.onclick = () => {
  // ...
}
#+END_SRC

此时就不能设置多个监听函数了。

2, inline event handlers(写 MDN 文档的人不建议使用)

#+BEGIN_SRC html
<button onclick="bgChange()">Press me</button>
#+END_SRC

事件对象

#+BEGIN_SRC js
function bgChange(e) {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  e.target.style.backgroundColor = rndCol;
  console.log(e.target);
}
#+END_SRC

=e.target= 指代的就是，触发特定事件的元素，这里就是 =button= 。

阻止事件默认行为

#+BEGIN_SRC js
const form = document.querySelector("form");
const fname = document.getElementById("fname");
const lname = document.getElementById("lname");
const para = document.querySelector("p");

form.addEventListener("submit", (e) => {
  if (fname.value === "" || lname.value === "") {
    e.preventDefault();
    para.innerHTML += "You need to fill in both names!<br>";
    para.style.color = "red";
  }
});
#+END_SRC

#+BEGIN_SRC html
<form>
  <div>
    <label for="fname">First name: </label>
    <input type="text" id="fname">
  </div>
  <div>
    <label for="lname">Last name: </label>
    <input type="text" id="lname">
  </div>
  <div>
    <input type="submit" id="submit">
  </div>

</form>
<p></p>
#+END_SRC

Event bubbling

#+BEGIN_SRC html
<body>
  <div id="container">
    <button>Click me!</button>
  </div>

  <pre id="output"></pre>
</body>
#+END_SRC

#+BEGIN_SRC js
const output = document.querySelector("#output");

function handleClick(e) {
  output.textContent += `You clicked on a ${e.currentTarget.tagName} element\n`;
}

const container = document.querySelector("#container");
const button = document.querySelector("button");

document.body.addEventListener("click", handleClick);
container.addEventListener("click", handleClick);
button.addEventListener("click", handleClick);
#+END_SRC

事件触发的顺序是由内而外，依次进行的。正是因为这种元素间的包含关系，在部分情况下，会造成用户的困扰。例如，这个[[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#video_player_example][视频播放器]]例子。例子中的问题可通过 ~stopPropagation()~ 解决，它能阻止事件传递到父元素。

Event capture - 事件繁殖的一种可选形式

它像 event bubbling 但顺序是反过来的。

Event delegation - 不必单独为子元素设置事件，只需要设置父元素，子元素会被自动包含。

** 作业：图片库

关键的 JS 内容：

#+BEGIN_SRC js
const displayedImage = document.querySelector(".displayed-img");
const thumbBar = document.querySelector(".thumb-bar");

const btn = document.querySelector("button");
const overlay = document.querySelector(".overlay");

/* Declaring the array of image filenames */
const images = ["pic1.jpg", "pic2.jpg", "pic3.jpg", "pic4.jpg", "pic5.jpg"];
/* Declaring the alternative text for each image file */
const alts = {
	"pic1.jpg": "Closeup of a human eye",
	"pic2.jpg": "draw",
	"pic3.jpg": "flower",
	"pic4.jpg": "ancient",
	"pic5.jpg": "butterfly",
};
/* Looping through images */
for (const image of images) {
	const newImage = document.createElement("img");
	newImage.setAttribute("src", `./images/${image}`);
	newImage.setAttribute("alt", alts[image]);
	thumbBar.appendChild(newImage);

	newImage.addEventListener("click", (event) => {
		displayedImage.src = event.target.src;
		displayedImage.alt = event.target.alt;
	});
}

/* Wiring up the Darken/Lighten button */
btn.addEventListener("click", (e) => {
	const btnClass = btn.getAttribute("class")
  if (btnClass === "dark") {
    btn.setAttribute("class", "light")
    btn.textContent = "Lighten"
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)"
  } else {
    btn.setAttribute("class", "dark")
    btn.textContent = "Darken"
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0)"
  }
});
#+END_SRC



* 对象

** 基础

#+BEGIN_SRC js
const person = {
  name: ["Bob", "Smith"],
  age: 32,
  bio: function() {
    console.log(`${this.name[0]} ${this.name[1]} is ${this.age} years old.`)
  },
  introduceSelf: function() {
    console.log(`Hi! I'm ${this.name[0]}.`)
  }
}
person.bio()
person.introduceSelf()

// 当对象的键值是函数时，function 关键字可省略

const person = {
  name: ["Bob", "Smith"],
  age: 32,
  bio() {
    console.log(`${this.name[0]} ${this.name[1]} is ${this.age} years old.`)
  },
  introduceSelf() {
    console.log(`Hi! I'm ${this.name[0]}.`)
  }
}
person.bio()
person.introduceSelf()
#+END_SRC

以上定义出来的对象，被称为模板字面量。

通过 ~.~ 或 ~[]~ 访问对象的键值。

将对象设为对象属性

#+BEGIN_SRC js
const person = {
  name: {
    first: "Bob",
    last: "Smith",
  },
  // ...
}

person.name.first
person.name.last
#+END_SRC

对象有时被称为 associative arrays，就是因为可以用 ~[]~ 访问内部键值。例如， ~person["name"]["first"]~ 。在某些情况下，只能用 ~[]~ ，比如，如果通过变量访问对象内部键值。

#+BEGIN_SRC js
const person = {
  name: ["Bob", "Smith"],
  age: 32,
};

function logProperty(propertyName) {
  console.log(person[propertyName])
};

logProperty("name")
#+END_SRC

设置对象键值

#+BEGIN_SRC js
person.age = 34
person["name"]["last"] = "Smith"
#+END_SRC

~this~ 指代什么

#+BEGIN_QUOTE
The =this= keyword refers to the current object the code is being written inside — so in this case =this= is equivalent to =person= .
#+END_QUOTE

#+BEGIN_SRC js
const person1 = {
  name: "Amy",
  introduceSelf() {
    console.log(`Hi! I'm ${this.name}.`)
  }
}
const person2 = {
  name: "Tom",
  introduceSelf() {
    console.log(`Hi! I'm ${this.name}.`)
  }
}
person1.introduceSelf()
person2.introduceSelf()
#+END_SRC

介绍构造器（constructors）

创建多个对象的一般方法：

#+BEGIN_SRC js
function createPerson(name) {
  const obj = {}
  obj.name = name
  obj.introduceSelf = function () {
    console.log(`Hi! I'm ${this.name}.`)
  }
  return obj
}

const salva = createPerson("Salva")
console.log(salva.name)
salva.introduceSelf()
const frankie = createPerson("Frankie")
console.log(frankie.name)
frankie.introduceSelf()
#+END_SRC

使用构造器创建多个对象：

#+BEGIN_SRC js
function Person(name) {
  this.name = name
  this.introduceSelf = function () {
    console.log(`Hi! I'm ${this.name}.`)
  }
}

const salva = new Person("Salva")
console.log(salva.name)
salva.introduceSelf()
const frankie = new Person("Frankie")
console.log(frankie.name)
frankie.introduceSelf()
#+END_SRC
